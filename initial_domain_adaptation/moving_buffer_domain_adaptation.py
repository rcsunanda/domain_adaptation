"""
Domain adaptation technique by maintaining a moving buffer of samples generated by a time varying GMM
"""
import domain_adaptation.initial_domain_adaptation.distribution_estimation as est
import domain_adaptation.initial_domain_adaptation.metrics as metrics
import domain_adaptation.initial_domain_adaptation.time_varying_gmm as tvgmm
import domain_adaptation.utility as utility

import numpy as np
import matplotlib.pyplot as plt




###################################################################################################
"""
Shift buffer to left (oldest elements are removed), and append given elements to end of buffer 
"""

def update_moving_buffer(moving_buffer, moving_buff_curr_sample_count, elements_to_add):
    new_list_size = len(elements_to_add)
    buffer_size = len(moving_buffer)

    # If buffer is not full with samples, add as many samples as possible to the buffer

    remaining_buff_length = buffer_size - moving_buff_curr_sample_count
    possible_add_count = 0  # For use in second if-block if the first if-block is not executed

    if (remaining_buff_length > 0):
        possible_add_count = min(remaining_buff_length, new_list_size)
        a = moving_buff_curr_sample_count
        b = moving_buff_curr_sample_count + possible_add_count
        moving_buffer[a: b] = elements_to_add[0: possible_add_count]


    # If some more elements remaining; shift buffer and append

    if (new_list_size > possible_add_count):
        remaining_elements = elements_to_add[possible_add_count:]
        remaining_element_count = new_list_size - possible_add_count

        # Shift elements to left (removed), and append new elements to right
        moving_buffer[0: buffer_size - remaining_element_count] = moving_buffer[remaining_element_count:]
        moving_buffer[buffer_size - remaining_element_count:] = remaining_elements

    return moving_buffer



###################################################################################################
"""
Test for update_moving_buffer()
"""

def test_update_moving_buffer():
    buffer_size = 10
    moving_buffer = np.zeros(buffer_size)

    init_sample_count = 5
    assert (buffer_size >= init_sample_count)   # Simplifying assumption

    moving_buffer[0:init_sample_count] = list(range(0, init_sample_count))

    moving_buff_curr_sample_count = init_sample_count

    print("moving_buffer_initial={}".format(moving_buffer))

    for i in range(1,5):  # do the move 4 times for testing
        new_list_size = 3   # 3 elements to add to moving list
        new_list = list(range(10*i, 10*i + new_list_size))

        moving_buffer = update_moving_buffer(moving_buffer, moving_buff_curr_sample_count, new_list)
        moving_buff_curr_sample_count += new_list_size

        print("iter={}, moving_buffer={}".format(i, moving_buffer))



###################################################################################################
"""
Compute and plot distance metrics between current true distribution and adapted estimated distribution
"""

metric_mse = []
metric_kl_div = []
metric_ks_stat = []
metric_emd = []

def compute_metrics(cdf_x_vals, estimated_ecdf, true_cdf, pdf_xvals, estimated_pdf, true_pdf):

    # print("----- Computing MSE -------")
    mse = metrics.mean_squared_error(cdf_x_vals, estimated_ecdf, true_cdf)

    # print("----- Computing EMD -------")
    # emd = metrics.emd(cdf_x_vals, estimated_ecdf, true_cdf)

    # print("----- Computing KS stat -------")
    x, ks_statistic = metrics.manual_ks_stat(cdf_x_vals, estimated_ecdf, true_cdf)

    # print("----- Computing KL divergence -------")
    kl_div = metrics.approx_kl_divergence(pdf_xvals, estimated_pdf, true_pdf)

    metric_mse.append(mse)
    metric_kl_div.append(kl_div)
    metric_ks_stat.append(ks_statistic)
    # metric_emd.append(emd)


def plot_metrics():
    metric_fig, (ax1, ax2, ax3, ax4) = plt.subplots(4, sharex=True)
    x = list(range(0,len(metric_mse)))

    ax1.plot(x, metric_mse)
    ax2.plot(x, metric_ks_stat)
    ax3.plot(x, metric_kl_div)
    # ax4.plot(x, metric_emd)

    # plt.legend(loc='upper right')
    plt.show()



###################################################################################################
"""
Create a time varying GMM, generate samples at each time point, and estimate ecdf and pdf using those samples
Plot to visualize the true pdf, generated samples, and estimated ecdf and pdf
"""

def moving_buffer_adaptation():

    if (plot_enabled):
        plt.figure()

    x = np.linspace(-10, 10, 1000)

    num_time_points = 15  # 3000 is a good number without the KL divergence call, 100 is good with it
    time_points = np.linspace(0, 2 * np.pi, num_time_points)

    initial_time = time_points[0]
    comp_weight_list = [1 / 3, 1 / 3, 1 / 3]
    component_time_params = [(0, 2, 1, 1.5, 1, 1), (-3, 2, 1, 2, 1, 1), (3, 2, 1, 0.8, 0.2, 1)]

    tv_gmm = tvgmm.TimeVaryingGMM(initial_time, comp_weight_list, component_time_params)

    # initial_gmm = tvgmm.TimeVaryingGMM(initial_time, comp_weight_list, component_time_params)
    #
    # initial_y = initial_gmm.get_current_pdf_curve(x)
    # plt.plot(x, initial_y, label='Reference pdf')

    plt.ion()


    # Create fixed size moving buffer and insert some generated samples

    K = 0.3   # Memory factor [0,1]
    buffer_size = int(1000 + 10000 * K)
    moving_buffer = np.zeros(buffer_size)

    init_sample_count = 1000
    assert (buffer_size >= init_sample_count)   # Simplifying assumption
    init_samples = tv_gmm.gmm.rvs(size=init_sample_count)

    moving_buffer[0:init_sample_count] = init_samples
    moving_buff_curr_sample_count = init_sample_count   # Required when some of the buffer is not filled with samples

    # utility.dump_data_to_csv("moving_buffer_init", moving_buffer)

    # For each time point, update GMM, generate samples and estimate new cdf/pdf

    for frame in range(num_time_points):

        # Update GMM (time varying)

        time = time_points[frame]
        tv_gmm.update_model(time)

        print("\t frame=%d, time=%.3f" % (frame, time))

        # print(tv_gmm)

        y = tv_gmm.get_current_pdf_curve(x)

        if (plot_enabled):
            pdf_plot, = plt.plot(x, y, color='red', label='Current pdf')


        # Generate samples and update moving buffer

        num_new_samples = 500
        new_samples = tv_gmm.gmm.rvs(size=num_new_samples)

        moving_buffer = update_moving_buffer(moving_buffer, moving_buff_curr_sample_count, new_samples)
        moving_buff_curr_sample_count += num_new_samples

        end = min(moving_buff_curr_sample_count, len(moving_buffer))
        current_valid_samples = moving_buffer[0:end]

        if (plot_enabled):
            # bin_width = 0.2
            # bins = np.arange(min(current_valid_samples), max(current_valid_samples) + bin_width, bin_width)
            # counts, bins_s, bars = plt.hist(current_valid_samples, normed=True, histtype='stepfilled', bins=bins, alpha=0.2,
            #                                 color='orange', label='Moving buffer histogram')

            bin_width = 0.2
            bins = np.arange(min(new_samples), max(new_samples) + bin_width, bin_width)
            counts, bins_s, bars = plt.hist(new_samples, normed=True, histtype='stepfilled', bins=bins, alpha=0.2,
                                            color='orange', label='New samples histogram')

        # utility.dump_data_to_csv("moving_buffer_iter_{}".format(frame), current_valid_samples)

        # Estimate and plot ecdf and pdf

        sorted, ecdf = est.estimate_ecdf(current_valid_samples)

        new_x, estimated_pdf = est.estimate_pdf(sorted, ecdf)

        compute_metrics(sorted, ecdf, tv_gmm.gmm.cdf, new_x, estimated_pdf, tv_gmm.gmm.pdf)

        if (plot_enabled):
            ecdf_plot, = plt.plot(sorted, ecdf, color='purple', label="estimated-ecdf")
            derivatives_plot, = plt.plot(new_x, estimated_pdf, color='green', label="estimated-pdf")

            plt.legend(loc='upper right')
            plt.xlabel('x')
            plt.pause(0.0001)

            # input("Press Enter to continue...")

            # Remove plots of current time point
            pdf_plot.remove()
            ecdf_plot.remove()
            derivatives_plot.remove()
            _ = [b.remove() for b in bars]  # Remove histogram


    plt.ioff()

    plot_metrics()



###################################################################################################

# Call functions

# test_update_moving_buffer()

plot_enabled = False
moving_buffer_adaptation()
